<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Creature - Parametric Life Form</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: rgb(9, 9, 9);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            display: flex;
            height: 100vh;
        }
        
        .left-panel {
            width: 20%;
            background: rgba(20, 20, 20, 0.8);
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .right-panel {
            width: calc(80% - 2cm);
            position: relative;
            margin: 1cm;
        }
        
        canvas {
            display: block;
            background: rgb(9, 9, 9);
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            cursor: pointer;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .recording {
            background: rgba(255, 50, 50, 0.3) !important;
            border-color: rgba(255, 50, 50, 0.7) !important;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .download-btn {
            background: rgba(0, 255, 150, 0.2);
            border-color: rgba(0, 255, 150, 0.5);
        }
        
        .download-btn:hover {
            background: rgba(0, 255, 150, 0.3);
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: right;
            line-height: 1.4;
        }
        
        .time-display {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-family: monospace;
        }
        
        .time-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: white;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .time-input-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .time-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            width: 60px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .time-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .quality-select, .color-scheme-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            width: 100%;
        }
        
        .quality-select option, .color-scheme-select option {
            background: rgb(30, 30, 30);
            color: white;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: white;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
        }
        
        input[type="range"] {
            width: 100%;
            accent-color: rgba(255, 255, 255, 0.7);
        }
        
        .title {
            text-align: center;
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .left-panel {
                width: 100%;
                height: auto;
                max-height: 40vh;
                overflow-y: auto;
            }
            
            .right-panel {
                width: 100%;
                height: 60vh;
            }
            
            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .time-controls, .slider-container {
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="left-panel">
        <div class="title">Mathematical Creature</div>
        <div class="controls">
            <button class="control-btn" onclick="toggleRecording()" id="recordBtn">⚫ Start Recording</button>
            <button class="control-btn download-btn" onclick="downloadVideo()" id="downloadBtn" style="display: none;">⬇ Download Video</button>
            <button class="control-btn" onclick="toggleAnimation()" id="playBtn">⏸ Pause</button>
            
            <div class="time-controls">
                <div class="time-input-row">
                    <span>Start:</span>
                    <input type="number" id="startTime" class="time-input" value="0" min="0" step="0.1">
                </div>
                <div class="time-input-row">
                    <span>End:</span>
                    <input type="number" id="endTime" class="time-input" value="12.56" min="0.1" step="0.1">
                    <span>s</span>
                </div>
            </div>
            
            <div class="time-controls">
                <span>Quality:</span>
                <select id="qualitySelect" class="quality-select">
                    <option value="high">High</option>
                    <option value="very-high" selected>Very High</option>
                    <option value="ultra">Ultra</option>
                </select>
            </div>
            
            <div class="time-controls">
                <span>Colors:</span>
                <select id="colorSchemeSelect" class="color-scheme-select" onchange="changeColorScheme()">
                    <option value="0">Romantic Blush</option>
                    <option value="1">Ocean Serenity</option>
                    <option value="2">Earthbound Elegance</option>
                    <option value="3">Smoky Monochrome</option>
                </select>
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Speed:</span>
                    <span id="speedValue">1.0x</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1" oninput="updateSpeed(this.value)">
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Particles:</span>
                    <span id="particleValue">10000</span>
                </div>
                <input type="range" id="particleSlider" min="1000" max="20000" step="1000" value="10000" oninput="updateParticleCount(this.value)">
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Complexity:</span>
                    <span id="complexityValue">1.0x</span>
                </div>
                <input type="range" id="complexitySlider" min="0.5" max="2" step="0.1" value="1" oninput="updateComplexity(this.value)">
            </div>
        </div>
    </div>
    
    <div class="right-panel">
        <canvas id="canvas"></canvas>
        <div class="time-display" id="timeDisplay">t = 0.000</div>
        <div class="info">
            Parametric Life Form<br>
            <span id="particleCountDisplay">10,000</span> points in motion<br>
            Mathematica equations converted
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Video recording setup
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let isAnimating = true;
        let recordingStartTime = 0;
        let recordingDuration = 0;
        let recordingStartT = 0;
        let recordingEndT = 0;
        let recordingInterval;
        
        // Color schemes with increased contrast
        const colorSchemes = [
            {
                name: "Romantic Blush",
                colors: [
                    [0.464, 0.129, 0.418, 1.0], // Deeper Aubergine
                    [0.818, 0.427, 0.508, 1.0], // Brighter Rose Gold
                    [0.952, 0.874, 0.767, 1.0]  // Lighter Champagne
                ]
            },
            {
                name: "Ocean Serenity",
                colors: [
                    [0.0, 0.402, 0.480, 1.0],   // Deeper Teal
                    [0.410, 0.716, 0.669, 1.0], // Brighter Emerald
                    [0.927, 0.916, 0.990, 1.0]  // Lighter Lilac
                ]
            },
            {
                name: "Earthbound Elegance",
                colors: [
                    [0.039, 0.237, 0.359, 1.0], // Deeper Blue
                    [0.661, 0.598, 0.410, 1.0], // Brighter Bronze
                    [0.991, 0.985, 0.940, 1.0]  // Lighter Pearl
                ]
            },
            {
                name: "Smoky Monochrome",
                colors: [
                    [0.3, 0.3, 0.3, 1.0],       // Lighter Grey
                    [0.653, 0.531, 0.488, 1.0], // Brighter Mauve
                    [0.978, 0.978, 0.978, 1.0]  // Lighter Silver
                ]
            }
        ];
        
        let currentColorScheme = 0;
        let animationSpeed = 0.02;
        let baseAnimationSpeed = 0.02;
        let particleCount = 10000;
        let complexityFactor = 1.0;
        
        // Canvas setup
        function resizeCanvas() {
            canvas.width = document.querySelector('.right-panel').clientWidth;
            canvas.height = document.querySelector('.right-panel').clientHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Animation parameters
        let t = 0;
        
        // Scale and offset for fitting to screen
        let scale, offsetX, offsetY;
        
        function updateScale() {
            const scaleX = canvas.width / 260; // Original range was 70-330
            const scaleY = canvas.height / 320; // Original range was 30-350
            scale = Math.min(scaleX, scaleY) * 0.8; // Leave some margin
            offsetX = (canvas.width - 260 * scale) / 2;
            offsetY = (canvas.height - 320 * scale) / 2;
        }
        
        function getColorForPoint(x, y, time, index, creatureIndex = 0) {
            const colors = colorSchemes[currentColorScheme].colors;
            
            // Calculate a value between 0 and 1 based on position and time
            const posFactor = (Math.sin(x * 0.01 + time) + 1) * 0.5;
            const timeFactor = (Math.sin(time * 2 + index * 0.0001) + 1) * 0.5;
            const blendFactor = (posFactor + timeFactor) * 0.5;
            
            // Determine which colors to blend between
            let colorIndex = Math.floor(blendFactor * (colors.length - 1));
            colorIndex = Math.min(colorIndex, colors.length - 2);
            
            const color1 = colors[colorIndex];
            const color2 = colors[colorIndex + 1];
            
            // Interpolate between the two colors
            const blend = (blendFactor * (colors.length - 1)) - colorIndex;
            
            // Apply creature-specific color shifts
            let r = color1[0] * (1 - blend) + color2[0] * blend;
            let g = color1[1] * (1 - blend) + color2[1] * blend;
            let b = color1[2] * (1 - blend) + color2[2] * blend;
            
            // Apply creature-specific color modifications
            if (creatureIndex === 1) { // First small creature
                sizeFactor = 0.7;
                timeOffset = Math.PI / 2;
                positionOffsetX = -80;
                positionOffsetY = 60; // Changed from 50 to 30 (moved up 20 units)
            } else if (creatureIndex === 2) { // Second small creature
                sizeFactor = 0.5;
                timeOffset = Math.PI;
                positionOffsetX = 50;
                positionOffsetY = -20; // Changed from -40 to -60 (moved up 20 units)
            } else if (creatureIndex === 3) { // Third small creature
                sizeFactor = 0.4;
                timeOffset = 3 * Math.PI / 2;
                positionOffsetX = -300;
                positionOffsetY = -60; // Changed from -80 to -100 (moved up 20 units)
            }
            
            // Ensure values are within valid range
            r = Math.min(1, Math.max(0, r));
            g = Math.min(1, Math.max(0, g));
            b = Math.min(1, Math.max(0, b));
            
            return `rgba(${Math.floor(r * 255)}, ${Math.floor(g * 255)}, ${Math.floor(b * 255)}, 0.9)`;
        }
        
        function generateCreaturePoints(time, creatureIndex = 0) {
            const points = [];
            const step = Math.floor(10000 / particleCount);
            
            // Creature-specific parameters
            let sizeFactor = 1.0;
            let timeOffset = 0;
            let positionOffsetX = 0;
            let positionOffsetY = 0;
            
            if (creatureIndex === 1) { // First small creature
                sizeFactor = 0.6;
                timeOffset = Math.PI / 2;
                positionOffsetX = -80;
                positionOffsetY = 50;
            } else if (creatureIndex === 2) { // Second small creature
                sizeFactor = 0.5;
                timeOffset = Math.PI;
                positionOffsetX = 100;
                positionOffsetY = -40;
            } else if (creatureIndex === 3) { // Third small creature
                sizeFactor = 0.4;
                timeOffset = 3 * Math.PI / 2;
                positionOffsetX = -120;
                positionOffsetY = -80;
            }
            
            // Generate points (i from 9999 to 0, step based on particle count)
            for (let i = 9999; i >= 0; i -= step) {
                const x = i;
                const y = i / 235.0;
                
                // Apply complexity factor to parameters
                const complexityTime = (time + timeOffset) * complexityFactor;
                const complexityX = x * complexityFactor;
                const complexityY = y * complexityFactor;
                
                // k = (4 + Sin[x/11 + 8*t]) * Cos[x/14]
                const k = (4 + Math.sin(complexityX/11 + 8*complexityTime)) * Math.cos(complexityX/14);
                
                // e = y/8 - 19
                const e = complexityY/8 - 19;
                
                // d = Sqrt[k^2 + e^2] + Sin[y/9 + 2*t]
                const d = Math.sqrt(k*k + e*e) + Math.sin(complexityY/9 + 2*complexityTime);
                
                // q = 2*Sin[2*k] + Sin[y/17]*k*(9 + 2*Sin[y - 3*d])
                const q = 2*Math.sin(2*k) + Math.sin(complexityY/17)*k*(9 + 2*Math.sin(complexityY - 3*d));
                
                // c = d^2/49 - t
                const c = (d*d)/49 - complexityTime;
                
                // xp = q + 50*Cos[c] + 200
                const xp = (q + 50*Math.cos(c) + 200) * sizeFactor + positionOffsetX;
                
                // yp = q*Sin[c] + d*39 - 440
                // Note: In Mathematica it's {xp, 400 - yp}, so we need to flip y
                const yp_raw = (q*Math.sin(c) + d*39 - 440) * sizeFactor + positionOffsetY;
                const yp = 400 - yp_raw;
                
                // Transform to screen coordinates
                const screenX = (xp - 70) * scale + offsetX;
                const screenY = (yp - 30) * scale + offsetY;
                
                // Only add points that are within reasonable bounds
                if (screenX >= -100 && screenX <= canvas.width + 100 && 
                    screenY >= -100 && screenY <= canvas.height + 100) {
                    points.push({
                        x: screenX,
                        y: screenY,
                        originalIndex: i
                    });
                }
            }
            
            return points;
        }
        
        function drawCreature() {
            // Clear canvas with dark gray background
            ctx.fillStyle = 'rgb(9, 9, 9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw main creature
            const mainPoints = generateCreaturePoints(t, 0);
            
            // Draw small creatures
            const smallCreature1Points = generateCreaturePoints(t, 1);
            const smallCreature2Points = generateCreaturePoints(t, 2);
            const smallCreature3Points = generateCreaturePoints(t, 3);
            
            // Combine all points
            const allPoints = [...mainPoints, ...smallCreature1Points, ...smallCreature2Points, ...smallCreature3Points];
            
            // Draw points
            const pointSize = Math.max(1, scale * 0.8);
            
            allPoints.forEach(point => {
                // Determine which creature this point belongs to
                let creatureIndex = 0;
                if (point.originalIndex >= 0 && point.originalIndex < 2500) creatureIndex = 0; // Main creature
                else if (point.originalIndex >= 2500 && point.originalIndex < 5000) creatureIndex = 1; // First small
                else if (point.originalIndex >= 5000 && point.originalIndex < 7500) creatureIndex = 2; // Second small
                else creatureIndex = 3; // Third small
                
                const color = getColorForPoint(point.x, point.y, t, point.originalIndex, creatureIndex);
                ctx.fillStyle = color;
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, pointSize * (creatureIndex === 0 ? 1 : 0.7), 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Add subtle glow effect for some points (every 50th point for performance)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            allPoints.forEach((point, index) => {
                if (index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, pointSize * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Update time display
            document.getElementById('timeDisplay').textContent = `t = ${t.toFixed(3)}`;
        }
        
        function animate() {
            if (isAnimating) {
                drawCreature();
                t += animationSpeed;
                
                // Loop after 4*PI (longer trajectory)
                if (t > 4 * Math.PI) {
                    t = 0;
                }
            }
            requestAnimationFrame(animate);
        }
        
        // Animation control
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const btn = document.getElementById('playBtn');
            btn.textContent = isAnimating ? '⏸ Pause' : '▶ Play';
        }
        
        // Interactive controls functions
        function updateSpeed(value) {
            animationSpeed = baseAnimationSpeed * value;
            document.getElementById('speedValue').textContent = value + 'x';
        }
        
        function updateParticleCount(value) {
            particleCount = parseInt(value);
            document.getElementById('particleValue').textContent = value;
            document.getElementById('particleCountDisplay').textContent = parseInt(value).toLocaleString();
        }
        
        function updateComplexity(value) {
            complexityFactor = parseFloat(value);
            document.getElementById('complexityValue').textContent = value + 'x';
        }
        
        function changeColorScheme() {
            const select = document.getElementById('colorSchemeSelect');
            currentColorScheme = parseInt(select.value);
        }
        
        // Recording functions
        function toggleRecording() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
        
        function startRecording() {
            // Get user-defined start and end times
            recordingStartT = parseFloat(document.getElementById('startTime').value) || 0;
            recordingEndT = parseFloat(document.getElementById('endTime').value) || (4 * Math.PI);
            
            // Validate times
            if (recordingStartT >= recordingEndT) {
                alert("Start time must be less than end time");
                return;
            }
            
            // Set t to the start time
            t = recordingStartT;
            drawCreature();
            
            recordedChunks = [];
            const stream = canvas.captureStream(60); // Increased to 60 FPS for smoother video
            
            // Get quality setting
            const quality = document.getElementById('qualitySelect').value;
            let videoBitsPerSecond;
            
            switch(quality) {
                case 'high':
                    videoBitsPerSecond = 5000000; // 5 Mbps
                    break;
                case 'very-high':
                    videoBitsPerSecond = 10000000; // 10 Mbps
                    break;
                case 'ultra':
                    videoBitsPerSecond = 20000000; // 20 Mbps
                    break;
                default:
                    videoBitsPerSecond = 10000000; // Default to 10 Mbps
            }
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: videoBitsPerSecond
            });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, {
                    type: 'video/webm'
                });
                
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.onclick = () => downloadBlob(blob, 'mathematical-creature.webm');
                downloadBtn.style.display = 'block';
                
                document.getElementById('recordBtn').textContent = '⚫ Start Recording';
                document.getElementById('recordBtn').classList.remove('recording');
                
                // Restore animation state
                isAnimating = true;
                clearInterval(recordingInterval);
            };
            
            mediaRecorder.start();
            isRecording = true;
            recordingStartTime = Date.now();
            
            document.getElementById('recordBtn').textContent = '⏹ Stop Recording';
            document.getElementById('recordBtn').classList.add('recording');
            
            // Calculate recording duration based on time range and animation speed
            recordingDuration = ((recordingEndT - recordingStartT) / animationSpeed) * 1000 / 60;
            
            // Update t at a fixed interval for recording
            clearInterval(recordingInterval);
            recordingInterval = setInterval(() => {
                if (isRecording) {
                    t += animationSpeed;
                    if (t >= recordingEndT) {
                        stopRecording();
                    }
                }
            }, 1000/60); // 60 FPS
            
            // Auto-stop when reaching end time
            setTimeout(() => {
                if (isRecording) {
                    stopRecording();
                }
            }, recordingDuration + 500); // Add a little buffer time
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
            }
        }
        
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function downloadVideo() {
            // This function will be dynamically updated when recording is complete
        }
        
        // Adjust scale based on window size
        window.addEventListener('resize', () => {
            resizeCanvas();
            updateScale();
        });
        
        // Initialize
        updateScale();
        
        // Start the animation
        animate();
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    toggleAnimation();
                    break;
                case 'r':
                    toggleRecording();
                    break;
                case 'ArrowLeft':
                    t -= 0.1;
                    if (t < 0) t = 4 * Math.PI - 0.1;
                    drawCreature();
                    break;
                case 'ArrowRight':
                    t += 0.1;
                    if (t > 4 * Math.PI) t = 0.1;
                    drawCreature();
                    break;
            }
        });
    </script>
</body>
</html>